<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GT7 Lap Tracker</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Colors: Oceanic Blue and Grays */
            --primary-color: #376893; /* Oceanic Blue */
            --primary-light-color: #4a7ea4; /* Lighter shade of blue for hover */
            --background-light: #F8F9FA; /* Very light gray for main background */
            --background-medium: #E9ECEF; /* Medium gray for filter background and even rows */
            --text-color: #343A40; /* Dark gray for general text */
            --heading-color: #2F5374; /* Slightly darker blue for headings */
            --border-color: #CED4DA; /* Soft gray for borders */
            --shadow-color: rgba(0, 0, 0, 0.1); /* Standard shadow */
            --fastest-lap-bg: #D4EDDA; /* Green for fastest lap */
            --fastest-lap-text: #155724;
            --error-color: #dc3545; /* Red for error messages */
            --success-color: #28a745; /* Green for success messages */
            --delete-button-color: #dc3545; /* Red for delete button */
            --delete-button-hover: #c82333; /* Darker red on hover */

            /* New Fonts */
            --main-font: 'Roboto', sans-serif;
            --display-font: 'Montserrat', sans-serif; 
        }

        body {
            font-family: var(--main-font);
            margin: 0;
            padding: 20px;
            background-color: var(--background-light);
            color: var(--text-color);
            line-height: 1.6;
        }

        h1, h2 {
            font-family: var(--display-font); /* Montserrat for headings */
            color: var(--heading-color);
            text-align: center;
            margin-bottom: 25px;
            font-weight: 700;
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            margin-bottom: 30px;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
        }

        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group select,
        .form-group input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 1rem;
            color: var(--text-color);
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: var(--main-font); /* Roboto for inputs */
        }

        .form-group input[type="text"]:focus,
        .form-group input[type="number"]:focus,
        .form-group select:focus,
        .form-group input[type="file"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(55, 104, 147, 0.25);
            outline: none;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-right: 15px;
            font-family: var(--display-font); /* Montserrat for buttons */
        }

        button:hover {
            background-color: var(--primary-light-color);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .delete-button {
            background-color: var(--delete-button-color);
            margin-right: 0; /* Override default button margin */
        }

        .delete-button:hover {
            background-color: var(--delete-button-hover);
        }

        .filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 15px;
            background-color: var(--background-medium);
            border-radius: 10px;
        }

        /* Container for the table that allows horizontal scrolling */
        .table-responsive {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch; /* For smoother scrolling on iOS */
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 2px 8px var(--shadow-color);
            border-radius: 8px;
            overflow: hidden; /* Important for border-radius to apply to content */
            font-family: var(--main-font); /* Roboto for the table */
            min-width: 800px; /* Ensures the table has a minimum width to enable scrolling on small screens if necessary */
        }

        table th, table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid var(--background-medium);
            white-space: nowrap; /* Prevents text from wrapping to multiple lines */
        }

        table th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 700;
            position: sticky;
            top: 0;
            z-index: 1;
            font-family: var(--display-font); /* Montserrat for table headers */
        }

        table tbody tr:nth-child(even) {
            background-color: var(--background-light);
        }

        table tbody tr:hover {
            background-color: var(--background-medium);
            transition: background-color 0.2s ease;
        }

        .fastest-lap {
            background-color: var(--fastest-lap-bg) !important;
            color: var(--fastest-lap-text);
            font-weight: bold;
        }
        
        .error-message {
            color: var(--error-color);
            margin-top: 5px;
            font-size: 0.875em;
            font-weight: 500;
        }

        .backup-section {
            margin-top: 30px;
            border-top: 1px solid var(--border-color);
            padding-top: 25px;
            text-align: center;
        }

        .backup-section p {
            margin-bottom: 15px;
            font-size: 0.95rem;
            color: var(--text-color);
        }

        /* Styles for the custom message box */
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }

        .message-box-overlay.visible {
            visibility: visible;
            opacity: 1;
        }

        .message-box {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .message-box-overlay.visible .message-box {
            transform: translateY(0);
        }

        .message-box h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-family: var(--display-font);
            font-weight: 700;
        }

        .message-box p {
            margin-bottom: 20px;
            color: var(--text-color);
        }

        .message-box .button-group {
            display: flex;
            justify-content: center;
            gap: 10px; /* Space between buttons */
        }

        .message-box button {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background-color 0.3s ease;
            margin-right: 0; /* Override default button margin */
        }

        .message-box button:hover {
            background-color: var(--primary-light-color);
        }

        .message-box button.cancel-button {
            background-color: var(--border-color);
            color: var(--text-color);
        }

        .message-box button.cancel-button:hover {
            background-color: #aeb4ba; /* Slightly darker gray */
        }


        .user-id-display {
            text-align: center;
            margin-top: 20px;
            color: var(--heading-color);
            font-family: var(--display-font);
            font-weight: 500;
            font-size: 0.9em;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            .container {
                padding: 20px;
            }
            .filters {
                grid-template-columns: 1fr;
            }
            button {
                width: 100%;
                margin-bottom: 10px;
                margin-right: 0;
            }
            table th, table td {
                padding: 10px;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>GT7 Lap Tracker</h1>

        <div class="user-id-display">
            Your User ID: <span id="currentUserId">Loading...</span>
        </div>

        <h2>Register New Lap</h2>
        <div class="form-group">
            <label for="nombrePiloto">Your Driver Name:</label>
            <input type="text" id="nombrePiloto" placeholder="Ex: MyGT7Nick" required>
        </div>
        <div class="form-group">
            <label for="circuito">Track:</label>
            <select id="circuito" onchange="populateLayoutSelect()" required>
                <option value="">Select a track</option>
            </select>
        </div>
        <div class="form-group">
            <label for="trazado">Layout:</label>
            <select id="trazado" required>
                <option value="">Select a layout</option>
            </select>
        </div>
        <div class="form-group">
            <label for="marcaCoche">Car Make:</label>
            <input type="text" id="marcaCoche" placeholder="Ex: Porsche" required>
        </div>
        <div class="form-group">
            <label for="modeloCoche">Car Model:</label>
            <input type="text" id="modeloCoche" placeholder="Ex: 911 GT3 RS" required>
        </div>
        <div class="form-group">
            <label for="prCoche">PR (Performance Rating):</label>
            <input type="number" id="prCoche" min="0" placeholder="Ex: 400" required>
            <div class="error-message" id="prCocheError"></div>
        </div>
        <div class="form-group">
            <label for="tiempoVuelta">Lap Time (mm:ss:SSS):</label>
            <input type="text" id="tiempoVuelta" pattern="[0-5]?\d:[0-5]?\d:\d{3}" placeholder="Ex: 01:30:123" required>
            <div class="error-message" id="tiempoVueltaError"></div>
        </div>
        <div class="form-group">
            <label for="lapVisibility">Lap Visibility:</label>
            <select id="lapVisibility" required>
                <option value="public">Public (visible to everyone)</option>
                <option value="private">Private (visible only to you)</option>
            </select>
        </div>
        <button onclick="registrarVuelta()">Register Lap</button>
    </div>

    <div class="container">
        <h2>Registered Laps</h2>

        <div class="filters">
            <div class="form-group">
                <label for="displayMode">Show Laps:</label>
                <select id="displayMode" onchange="saveDisplayModePreference(); aplicarFiltros()">
                    <option value="all">All Laps (Public + My Private)</option>
                    <option value="mine">My Laps Only (Public by me + My Private)</option>
                </select>
            </div>
            <div class="form-group">
                <label for="filterNombrePiloto">Filter by Driver:</label>
                <select id="filterNombrePiloto" onchange="aplicarFiltros()">
                    <option value="">All Drivers</option>
                </select>
            </div>
            <div class="form-group">
                <label for="filterCircuito">Filter by Track:</label>
                <input type="text" id="filterCircuito" onkeyup="aplicarFiltros()" placeholder="All">
            </div>
            <div class="form-group">
                <label for="filterMarcaCoche">Filter by Make:</label>
                <input type="text" id="filterMarcaCoche" onkeyup="aplicarFiltros()" placeholder="All">
            </div>
            <div class="form-group">
                <label for="filterModeloCoche">Filter by Model:</label>
                <input type="text" id="filterModeloCoche" onkeyup="aplicarFiltros()" placeholder="All">
            </div>
            <div class="form-group">
                <label for="filterPrCoche">Filter by PR:</label>
                <input type="number" id="filterPrCoche" onkeyup="aplicarFiltros()" placeholder="All">
            </div>
        </div>

        <div class="table-responsive">
            <table id="tablaVueltas">
                <thead>
                    <tr>
                        <th>Driver</th>
                        <th>Track</th>
                        <th>Layout</th>
                        <th>Make</th>
                        <th>Model</th>
                        <th>PR</th>
                        <th>Time</th>
                        <th>Difference</th>
                        <th>Visibility</th>
                        <th>Actions</th> <!-- New column for actions -->
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        </div>

        <div class="backup-section">
            <h2>Data Management (Backup/Restore)</h2>
            <p>You can download your lap data as a backup file or upload a backup file to restore your data.</p>
            <button onclick="descargarDatos()">Download Backup</button>
            <input type="file" id="subirBackupInput" accept=".json" style="display: none;" onchange="subirDatos(event)">
            <button onclick="document.getElementById('subirBackupInput').click()">Upload Backup</button>
        </div>
    </div>

    <div id="messageBoxOverlay" class="message-box-overlay">
        <div class="message-box">
            <h3 id="messageBoxTitle"></h3>
            <p id="messageBoxContent"></p>
            <div class="button-group" id="messageBoxButtons">
                <!-- Buttons will be dynamically added here -->
            </div>
        </div>
    </div>

    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, setDoc, doc, query, where, deleteDoc } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore.js";

        // Firebase configuration (replace with your actual Firebase project config)
        const userProvidedFirebaseConfig = {
          apiKey: "AIzaSyBYBH1FmAakCH9_istuLv7GgJ65CYimE4U",
          authDomain: "gt7-lap-tracker.firebaseapp.com",
          databaseURL: "https://gt7-lap-tracker-default-rtdb.europe-west1.firebasedatabase.app",
          projectId: "gt7-lap-tracker",
          storageBucket: "gt7-lap-tracker.firebasestorage.app",
          messagingSenderId: "234690775897",
          appId: "1:234690775897:web:93ac912709ca3fe45a9a48",
          measurementId: "G-B6VQWS2B98"
        };

        // Determine Firebase config and app ID for Canvas environment or fallback
        const firebaseConfig = typeof __firebase_config !== 'undefined'
                               ? JSON.parse(__firebase_config)
                               : userProvidedFirebaseConfig;

        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.appId;

        // Use __initial_auth_token for authentication if available
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = 'loading'; // Default to loading state
        let isAuthReady = false; // Flag to indicate if authentication is complete

        const MY_DRIVER_NAME_KEY = 'myDriverName'; // Used for storing the user's driver name locally
        const DISPLAY_MODE_KEY = 'gt7DisplayMode'; // Used for local display preference

        let vueltas = []; // Local array to hold laps fetched from Firestore

        // Gran Turismo 7 Circuits and Layouts (This data is fine)
        const circuitosGT7 = {
            "Asia-Pacific": {
                "Autopolis International Racing Course": [],
                "Broad Bean Raceway": [],
                "Fuji International Speedway": [],
                "High Speed Ring": [],
                "Kyoto Driving Park": ["Miyabi", "Yamagiwa", "Yamagiwa + Miyabi"],
                "Mount Panorama": [],
                "Suzuka Circuit": ["Suzuka Circuit East"],
                "Tokyo Expressway": ["Central Inner Loop", "Central Outer Loop", "East Inner Loop", "East Outer Loop", "South Inner Loop", "South Outer Loop"],
                "Tsukuba Circuit": []
            },
            "America": {
                "Autódromo José Carlos Pace": [],
                "Blue Moon Bay Speedway": [],
                "Colorado Springs": [],
                "Daytona International Speedway": ["Daytona Superspeedway", "Daytona Road Course"],
                "Fisherman’s Ranch": [],
                "Northern Isle Speedway": [],
                "Trial Mountain Circuit": [],
                "Special Stage Route X": [],
                "WeatherTech Raceway Laguna Seca": [],
                "Willow Springs International Raceway": ["Big Willow"]
            },
            "Europe": {
                "Alsace – Village": [],
                "Autodrome Lago Maggiore": [],
                "Autodromo Nazionale Monza": [],
                "Brands Hatch": [],
                "Circuit de Barcelona-Catalunya": [],
                "Circuit de la Sarthe": [],
                "Circuit de Sainte-Croix": ["A", "B", "C"],
                "Circuit de Spa-Francorchamps": [],
                "Deep Forest Raceway": [],
                "Dragon Trail": ["Gardens", "Seaside"],
                "Goodwood Motor Circuit": [],
                "Nürburgring": ["24h", "Nordschleife"],
                "Red Bull Ring": [],
                "Sardegna": ["Road Track – A", "Road Track – B", "Road Track – C"],
                "Windmills": []
            }
        };

        /**
         * Converts a time string (mm:ss:SSS) to milliseconds.
         * @param {string} timeStr - The time string to convert.
         * @returns {number} The time in milliseconds, or NaN if invalid.
         */
        function timeToMilliseconds(timeStr) {
            const parts = timeStr.split(':');
            if (parts.length !== 3) return NaN;

            const minutes = parseInt(parts[0], 10);
            const seconds = parseInt(parts[1], 10);
            const milliseconds = parseInt(parts[2], 10);

            if (isNaN(minutes) || isNaN(seconds) || isNaN(milliseconds)) return NaN;

            return (minutes * 60 * 1000) + (seconds * 1000) + milliseconds;
        }

        /**
         * Converts milliseconds to a time string (mm:ss:SSS).
         * @param {number} ms - The time in milliseconds.
         * @returns {string} The formatted time string.
         */
        function millisecondsToTime(ms) {
            if (isNaN(ms)) return 'N/A';

            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = ms % 1000;

            // Pad with leading zeros to ensure correct format
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(3, '0')}`;
        }

        /**
         * Displays a custom message box.
         * @param {string} message - The message content.
         * @param {string} [title='Message'] - The title of the message box.
         * @param {function} [onConfirm=null] - Callback function for "OK" or "Confirm" action.
         * @param {function} [onCancel=null] - Callback function for "Cancel" action.
         */
        function showMessageBox(message, title = 'Message', onConfirm = null, onCancel = null) {
            const overlay = document.getElementById('messageBoxOverlay');
            const titleElement = document.getElementById('messageBoxTitle');
            const contentElement = document.getElementById('messageBoxContent');
            const buttonGroup = document.getElementById('messageBoxButtons');

            titleElement.textContent = title;
            contentElement.textContent = message;
            buttonGroup.innerHTML = ''; // Clear existing buttons

            if (onConfirm) {
                // If onConfirm is provided, it's a confirmation dialog
                const confirmButton = document.createElement('button');
                confirmButton.textContent = 'OK';
                confirmButton.onclick = () => {
                    closeMessageBox();
                    onConfirm();
                };
                buttonGroup.appendChild(confirmButton);

                if (onCancel) {
                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = 'Cancel';
                    cancelButton.classList.add('cancel-button');
                    cancelButton.onclick = () => {
                        closeMessageBox();
                        onCancel();
                    };
                    buttonGroup.appendChild(cancelButton);
                }
            } else {
                // If no onConfirm, it's a simple alert-like message
                const okButton = document.createElement('button');
                okButton.textContent = 'OK';
                okButton.onclick = closeMessageBox;
                buttonGroup.appendChild(okButton);
            }

            overlay.classList.add('visible');
        }

        /**
         * Closes the custom message box.
         */
        function closeMessageBox() {
            const overlay = document.getElementById('messageBoxOverlay');
            overlay.classList.remove('visible');
        }

        /**
         * Populates the Track dropdown in the registration form.
         */
        function populateTrackSelect() {
            const trackSelect = document.getElementById('circuito');
            trackSelect.innerHTML = '<option value="">Select a track</option>'; // Default empty option

            // Iterate through regions and tracks to create optgroups and options
            for (const region in circuitosGT7) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = region;
                
                // Get the tracks for this region
                const tracks = circuitosGT7[region];
                
                // Iterate through the tracks in this region
                for (const trackName in tracks) {
                    const option = document.createElement('option');
                    option.value = trackName;
                    option.textContent = trackName;
                    optgroup.appendChild(option);
                }
                
                trackSelect.appendChild(optgroup);
            }
            populateLayoutSelect(); // Also populate layout on initial load (or track change)
        }

        /**
         * Populates the Layout dropdown based on the currently selected track.
         */
        function populateLayoutSelect() {
            const trackSelect = document.getElementById('circuito');
            const layoutSelect = document.getElementById('trazado');
            const selectedTrack = trackSelect.value;

            // Clear all previous options first
            layoutSelect.innerHTML = ''; 

            if (selectedTrack) { 
                let layouts = [];
                let trackFoundInCircuitosGT7 = false; 

                for (const region in circuitosGT7) {
                    if (circuitosGT7[region][selectedTrack]) { 
                        layouts = circuitosGT7[region][selectedTrack];
                        trackFoundInCircuitosGT7 = true; 
                        break; 
                    }
                }

                if (layouts.length > 0) { 
                    // Add a default "Select a layout" option for tracks with multiple layouts
                    const defaultEmptyOption = document.createElement('option');
                    defaultEmptyOption.value = "";
                    defaultEmptyOption.textContent = "Select a layout";
                    layoutSelect.appendChild(defaultEmptyOption);

                    // Add the actual layouts
                    layouts.forEach(layout => {
                        const option = document.createElement('option');
                        option.value = layout;
                        option.textContent = layout;
                        layoutSelect.appendChild(option);
                    });
                    layoutSelect.value = ""; // Ensure the default empty option is selected initially
                } else { 
                    // If no specific layouts, the track itself is the only layout
                    const option = document.createElement('option');
                    option.value = selectedTrack;
                    option.textContent = selectedTrack;
                    layoutSelect.appendChild(option);
                    layoutSelect.value = selectedTrack; // Automatically select this single option
                }
            } else {
                // If no track is selected in the 'circuito' dropdown, just show the default "Select a layout"
                const defaultEmptyOption = document.createElement('option');
                defaultEmptyOption.value = "";
                defaultEmptyOption.textContent = "Select a layout";
                layoutSelect.appendChild(defaultEmptyOption);
                layoutSelect.value = "";
            }
        }

        // Expose to global scope for HTML onclick attributes
        window.populateLayoutSelect = populateLayoutSelect;
        window.registrarVuelta = registrarVuelta;
        window.aplicarFiltros = aplicarFiltros;
        window.saveDisplayModePreference = saveDisplayModePreference;
        window.descargarDatos = descargarDatos;
        window.subirDatos = subirDatos;
        window.closeMessageBox = closeMessageBox; // Expose close function
        window.deleteLap = deleteLap; // Expose deleteLap function

        // Event listener for when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', async () => {
            // Populate UI elements immediately, even if Firebase isn't fully ready yet
            populateTrackSelect(); 
            populateDriverFilter(); 
            loadDisplayModePreference(); 

            // Load driver name from local storage
            const storedDriverName = localStorage.getItem(MY_DRIVER_NAME_KEY);
            if (storedDriverName) {
                document.getElementById('nombrePiloto').value = storedDriverName;
            }

            // Initialize Firebase App
            if (firebaseConfig.apiKey && firebaseConfig.projectId && firebaseConfig.authDomain) {
                try {
                    app = initializeApp(firebaseConfig);
                    auth = getAuth(app);
                    db = getFirestore(app);

                    // Authenticate using the provided token if available, otherwise sign in anonymously
                    if (initialAuthToken) {
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Signed in with custom token.");
                        } catch (error) {
                            console.error("Error signing in with custom token, falling back to anonymous:", error);
                            await signInAnonymously(auth);
                        }
                    } else {
                        await signInAnonymously(auth);
                    }

                    // Set up authentication listener
                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            document.getElementById('currentUserId').textContent = userId;
                            console.log("Firebase authenticated. User ID:", userId);
                            isAuthReady = true; 
                            
                            // Load and display laps only after authentication is ready
                            await loadLapsFromFirestore(); 
                            populateDriverFilter(); 
                            aplicarFiltros(); 

                        } else {
                            console.warn("No Firebase user signed in after onAuthStateChanged. Check authentication setup.");
                            document.getElementById('currentUserId').textContent = 'Authentication Failed';
                            isAuthReady = false; 
                            displayLaps(); 
                        }
                    });

                } catch (error) {
                    console.error("Error initializing Firebase or during initial authentication:", error);
                    showMessageBox("Firebase initialization failed. Please check your console for errors and ensure your Firebase configuration and settings are correct (e.g., Anonymous sign-in enabled, Firestore rules).", "Initialization Error");
                    document.getElementById('currentUserId').textContent = 'Firebase Error';
                    isAuthReady = false;
                    displayLaps(); 
                }
            } else {
                showMessageBox("Firebase configuration is missing or incomplete. Data persistence will be disabled. Please update 'firebaseConfig' in the script.", "Configuration Error");
                document.getElementById('currentUserId').textContent = 'Firebase Not Configured';
                isAuthReady = false; 
                displayLaps(); 
            }
        });

        /**
         * Loads all relevant lap data from Firestore (public laps and current user's private laps).
         * Updates the global `vueltas` array.
         */
        async function loadLapsFromFirestore() {
            if (!isAuthReady || !db || !auth.currentUser) {
                console.log("Firestore not ready or user not authenticated. Skipping data load.");
                vueltas = []; 
                displayLaps(); 
                return;
            }

            vueltas = []; // Clear existing laps
            try {
                // 1. Fetch Public Laps
                const publicLapsCollectionRef = collection(db, `artifacts/${appId}/public/data/laps`);
                const publicQuerySnapshot = await getDocs(publicLapsCollectionRef);
                publicQuerySnapshot.forEach((doc) => {
                    vueltas.push({ id: doc.id, ...doc.data(), visibility: 'public' });
                });
                console.log(`Loaded ${publicQuerySnapshot.size} public laps.`);

                // 2. Fetch Current User's Private Laps
                // Ensure userId is truly available before trying to fetch private data
                if (userId && userId !== 'loading' && userId !== 'anonymous_loading' && userId !== 'Firebase Error' && userId !== 'Firebase Not Configured') {
                    const privateLapsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/laps`);
                    const privateQuerySnapshot = await getDocs(privateLapsCollectionRef);
                    privateQuerySnapshot.forEach((doc) => {
                        vueltas.push({ id: doc.id, ...doc.data(), visibility: 'private' });
                    });
                    console.log(`Loaded ${privateQuerySnapshot.size} private laps for user ${userId}.`);
                } else {
                    console.warn("User ID not valid for fetching private laps. Skipping private data load.");
                }

                console.log("Total laps loaded:", vueltas.length);

            } catch (e) {
                console.error("Error loading documents from Firestore: ", e);
                showMessageBox("Error loading laps. Please check your internet connection and Firebase Firestore security rules for both public and private data paths.", "Data Load Error");
            }
        }

        /**
         * Validates the lap time format (mm:ss:SSS).
         * @param {string} time - The time string to validate.
         * @returns {boolean} True if valid, false otherwise.
         */
        function validateTime(time) {
            const regex = /^\d{2}:\d{2}:\d{3}$/;
            return regex.test(time);
        }

        /**
         * Registers a new lap by gathering form data, validating it,
         * and adding it to the appropriate Firestore collection (public or private).
         */
        async function registrarVuelta() {
            if (!db || !auth.currentUser) {
                showMessageBox("Database not initialized or user not authenticated. Please refresh the page or check Firebase configuration.", "Error");
                return;
            }

            const driverName = document.getElementById('nombrePiloto').value.trim();
            const track = document.getElementById('circuito').value.trim();
            const layout = document.getElementById('trazado').value.trim();
            const carMake = document.getElementById('marcaCoche').value.trim();
            const carModel = document.getElementById('modeloCoche').value.trim();
            const prCarInput = document.getElementById('prCoche');
            const prCar = prCarInput.value.trim();
            const lapTime = document.getElementById('tiempoVuelta').value.trim();
            const lapVisibility = document.getElementById('lapVisibility').value; // Get visibility choice
            const lapTimeError = document.getElementById('tiempoVueltaError');
            const prCarError = document.getElementById('prCocheError');

            // Clear previous error messages
            lapTimeError.textContent = '';
            prCarError.textContent = '';

            // Basic validation
            if (!driverName || !track || !layout || !carMake || !carModel || !prCar || !lapTime) {
                showMessageBox("Please fill in all fields.", "Validation Error");
                return;
            }

            if (isNaN(parseInt(prCar)) || parseInt(prCar) < 0) {
                prCarError.textContent = 'PR must be a non-negative number.';
                return;
            }

            if (!validateTime(lapTime)) {
                lapTimeError.textContent = 'Lap Time must be in mm:ss:SSS format (e.g., 01:30:123).';
                return;
            }

            const lapTimeMs = timeToMilliseconds(lapTime);
            if (isNaN(lapTimeMs)) {
                lapTimeError.textContent = 'Invalid lap time. Please use mm:ss:SSS format.';
                return;
            }

            // Save driver name to local storage
            localStorage.setItem(MY_DRIVER_NAME_KEY, driverName);

            const newLap = {
                userId: userId, // Store the user ID with the lap
                driverName: driverName,
                track: track,
                layout: layout,
                carMake: carMake,
                carModel: carModel,
                prCar: parseInt(prCar, 10),
                lapTime: lapTime,
                lapTimeMs: lapTimeMs, // Store milliseconds for easier sorting and comparison
                timestamp: Date.now() // Timestamp for ordering
            };

            let collectionPath;
            if (lapVisibility === 'public') {
                collectionPath = `artifacts/${appId}/public/data/laps`;
            } else { // 'private'
                collectionPath = `artifacts/${appId}/users/${userId}/laps`;
            }
            newLap.visibility = lapVisibility; // Add visibility property to the stored lap

            try {
                const docRef = await addDoc(collection(db, collectionPath), newLap);
                console.log(`Lap registered as ${lapVisibility} with ID: `, docRef.id);
                showMessageBox("Lap registered successfully!", "Success");

                // After successful registration, reload and display laps
                await loadLapsFromFirestore();
                populateDriverFilter(); // Re-populate driver filter as new driver might be added
                aplicarFiltros(); // Apply filters and display updated data
                clearForm();
            } catch (e) {
                console.error("Error adding document: ", e);
                showMessageBox(`Error registering lap as ${lapVisibility}. Please check your internet connection or Firebase Firestore security rules.`, "Registration Error");
            }
        }

        /**
         * Clears the input fields in the registration form.
         */
        function clearForm() {
            // Keep driver name, clear others
            document.getElementById('circuito').value = '';
            document.getElementById('trazado').value = '';
            document.getElementById('marcaCoche').value = '';
            document.getElementById('modeloCoche').value = '';
            document.getElementById('prCoche').value = '';
            document.getElementById('tiempoVuelta').value = '';
            document.getElementById('lapVisibility').value = 'public'; // Reset to public
            populateLayoutSelect(); // Reset layout dropdown
        }

        /**
         * Populates the "Filter by Driver" dropdown with unique driver names from the loaded laps.
         */
        function populateDriverFilter() {
            const filterDriverSelect = document.getElementById('filterNombrePiloto');
            const currentSelectedDriver = filterDriverSelect.value; // Save current selection

            filterDriverSelect.innerHTML = '<option value="">All Drivers</option>'; // Always have "All Drivers" option

            // Create a set of unique driver names from all loaded laps
            const uniqueDrivers = new Set(vueltas.map(lap => lap.driverName));
            uniqueDrivers.forEach(driver => {
                const option = document.createElement('option');
                option.value = driver;
                option.textContent = driver;
                filterDriverSelect.appendChild(option);
            });

            // Restore previous selection if it still exists
            if (currentSelectedDriver && uniqueDrivers.has(currentSelectedDriver)) {
                filterDriverSelect.value = currentSelectedDriver;
            } else {
                filterDriverSelect.value = ''; // Reset to "All Drivers" if previous selection is no longer valid
            }
        }

        /**
         * Applies filters and updates the displayed lap table.
         * Filters include display mode (all/mine), driver name, track, car make, car model, and PR.
         * The results are sorted by track, layout, and then lap time.
         */
        function aplicarFiltros() {
            const displayMode = document.getElementById('displayMode').value;
            const filterDriver = document.getElementById('filterNombrePiloto').value.toLowerCase();
            const filterTrack = document.getElementById('filterCircuito').value.toLowerCase();
            const filterMake = document.getElementById('filterMarcaCoche').value.toLowerCase();
            const filterModel = document.getElementById('filterModeloCoche').value.toLowerCase();
            const filterPr = document.getElementById('filterPrCoche').value;

            let filteredVueltas = vueltas.filter(lap => {
                const matchesDriver = filterDriver === '' || lap.driverName.toLowerCase().includes(filterDriver);
                const matchesTrack = filterTrack === '' || lap.track.toLowerCase().includes(filterTrack);
                const matchesMake = filterMake === '' || lap.carMake.toLowerCase().includes(filterMake);
                const matchesModel = filterModel === '' || lap.carModel.toLowerCase().includes(filterModel);
                const matchesPr = filterPr === '' || (lap.prCar && lap.prCar.toString().includes(filterPr)); // Check if prCar exists before toString

                let matchesDisplayMode = true;
                // 'mine' mode: show only laps belonging to the current user (either public or private)
                // We ensure userId is valid before attempting to filter by it
                if (displayMode === 'mine' && userId && userId !== 'loading' && userId !== 'anonymous_loading' && userId !== 'Firebase Error' && userId !== 'Firebase Not Configured') {
                    matchesDisplayMode = lap.userId === userId;
                }
                
                return matchesDriver && matchesTrack && matchesMake && matchesModel && matchesPr && matchesDisplayMode;
            });

            // Sort filtered laps: by Track, then Layout, then Lap Time (milliseconds)
            filteredVueltas.sort((a, b) => {
                // Primary sort: Track (alphabetical)
                const trackCompare = a.track.localeCompare(b.track);
                if (trackCompare !== 0) return trackCompare;

                // Secondary sort: Layout (alphabetical)
                const layoutA = a.layout || a.track; // Use track if layout is not specified
                const layoutB = b.layout || b.track;
                const layoutCompare = layoutA.localeCompare(layoutB);
                if (layoutCompare !== 0) return layoutCompare;

                // Tertiary sort: Lap Time (fastest first)
                return a.lapTimeMs - b.lapTimeMs;
            });

            displayLaps(filteredVueltas);
        }

        /**
         * Displays the given array of lap data in the table.
         * Identifies and marks the fastest lap for each unique track/layout combination.
         * @param {Array} [lapsToDisplay=vueltas] - The array of lap objects to display. Defaults to the global `vueltas` array if not provided.
         */
        function displayLaps(lapsToDisplay = vueltas) {
            const tableBody = document.querySelector('#tablaVueltas tbody');
            tableBody.innerHTML = ''; // Clear existing rows

            if (lapsToDisplay.length === 0) {
                const row = tableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 10; // Updated colspan to include the new 'Actions' column
                cell.textContent = "No laps to display. Try registering one or adjusting your filters.";
                cell.style.textAlign = 'center';
                cell.style.padding = '20px';
                return;
            }

            const fastestLaps = {}; // Stores the fastest lap for each track/layout combo { 'TrackName_LayoutName': fastestTimeMs }

            // First pass: Determine the fastest lap for each unique track/layout
            // This needs to be done *after* filtering by displayMode, but before adding rows
            // To ensure "fastest" is relative to the currently displayed set.
            lapsToDisplay.forEach(lap => {
                const key = `${lap.track}_${lap.layout}`;
                if (!fastestLaps[key] || lap.lapTimeMs < fastestLaps[key].lapTimeMs) {
                    fastestLaps[key] = { time: lap.lapTime, lapTimeMs: lap.lapTimeMs };
                }
            });

            // Second pass: Populate the table
            lapsToDisplay.forEach(lap => {
                const row = tableBody.insertRow();

                const key = `${lap.track}_${lap.layout}`;
                const isFastestLap = fastestLaps[key] && lap.lapTimeMs === fastestLaps[key].lapTimeMs;

                if (isFastestLap) {
                    row.classList.add('fastest-lap');
                }

                row.insertCell().textContent = lap.driverName;
                row.insertCell().textContent = lap.track;
                row.insertCell().textContent = lap.layout;
                row.insertCell().textContent = lap.carMake;
                row.insertCell().textContent = lap.carModel;
                row.insertCell().textContent = lap.prCar;
                row.insertCell().textContent = lap.lapTime;

                // Calculate and display difference from fastest lap for the track/layout
                if (fastestLaps[key] && lap.lapTimeMs !== fastestLaps[key].lapTimeMs) {
                    const differenceMs = lap.lapTimeMs - fastestLaps[key].lapTimeMs;
                    const sign = differenceMs > 0 ? '+' : ''; // Add '+' for positive differences
                    row.insertCell().textContent = `${sign}${millisecondsToTime(Math.abs(differenceMs))}`;
                } else {
                    row.insertCell().textContent = ''; // No difference for the fastest lap
                }
                row.insertCell().textContent = lap.visibility === 'private' ? 'Private' : 'Public'; // Display visibility

                // Add delete button if the lap belongs to the current user (only for their own laps)
                const actionCell = row.insertCell();
                if (lap.userId === userId) { // Only show delete button for the current user's laps
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'Delete';
                    deleteButton.classList.add('delete-button');
                    // Pass lap.id, lap.visibility, and lap.userId to the delete function
                    deleteButton.onclick = () => deleteLap(lap.id, lap.visibility, lap.userId);
                    actionCell.appendChild(deleteButton);
                } else {
                    actionCell.textContent = ''; // No action for other users' laps
                }
            });
        }

        /**
         * Deletes a lap from Firestore.
         * @param {string} lapId - The ID of the lap document to delete.
         * @param {string} lapVisibility - 'public' or 'private', to determine the collection path.
         * @param {string} lapUserId - The userId associated with the lap (used for private laps).
         */
        async function deleteLap(lapId, lapVisibility, lapUserId) {
            if (!db || !auth.currentUser) {
                showMessageBox("Database not initialized or user not authenticated. Cannot delete lap.", "Error");
                return;
            }

            // Confirm deletion with the user
            showMessageBox(
                "Are you sure you want to delete this lap record? This action cannot be undone.",
                "Confirm Deletion",
                async () => { // onConfirm callback
                    let collectionPath;
                    if (lapVisibility === 'public') {
                        collectionPath = `artifacts/${appId}/public/data/laps`;
                    } else if (lapVisibility === 'private' && lapUserId === userId) {
                        // Ensure we are only deleting a private lap if it truly belongs to the current user
                        collectionPath = `artifacts/${appId}/users/${lapUserId}/laps`;
                    } else {
                        showMessageBox("Error: You do not have permission to delete this lap or invalid visibility.", "Permission Denied");
                        return;
                    }

                    try {
                        await deleteDoc(doc(db, collectionPath, lapId));
                        console.log(`Lap with ID ${lapId} (Visibility: ${lapVisibility}) deleted successfully.`);
                        showMessageBox("Lap deleted successfully!", "Success");
                        
                        // After successful deletion, reload and display laps
                        await loadLapsFromFirestore();
                        populateDriverFilter();
                        aplicarFiltros();
                    } catch (e) {
                        console.error("Error deleting document: ", e);
                        showMessageBox(`Error deleting lap. Please check your internet connection or Firebase Firestore security rules for deletion.`, "Deletion Error");
                    }
                },
                () => { // onCancel callback
                    console.log("Lap deletion cancelled.");
                }
            );
        }


        /**
         * Saves the user's preferred display mode ('all' or 'mine') to local storage.
         */
        function saveDisplayModePreference() {
            const displayMode = document.getElementById('displayMode').value;
            localStorage.setItem(DISPLAY_MODE_KEY, displayMode);
        }

        /**
         * Loads the user's preferred display mode from local storage and applies it.
         */
        function loadDisplayModePreference() {
            const storedDisplayMode = localStorage.getItem(DISPLAY_MODE_KEY);
            if (storedDisplayMode) {
                document.getElementById('displayMode').value = storedDisplayMode;
            }
        }

        /**
         * Downloads all current lap data as a JSON file.
         */
        function descargarDatos() {
            // For backup, download all laps (public + private) currently loaded in 'vueltas'
            const dataToBackup = vueltas.map(lap => {
                // Exclude the 'id' which is Firestore's document ID, it will be recreated on upload
                const { id, ...rest } = lap; 
                return rest;
            });
            const dataStr = JSON.stringify(dataToBackup, null, 2); // Pretty print JSON
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gt7_lap_data_backup_${userId}.json`; // Include user ID in filename
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox("Your lap data has been downloaded.", "Backup Complete");
        }

        /**
         * Handles uploading a JSON backup file to restore lap data.
         * Uploaded data will be stored as PRIVATE laps for the current user.
         * Existing private laps are NOT cleared; new ones are added.
         * @param {Event} event - The file input change event.
         */
        async function subirDatos(event) {
            if (!db || !auth.currentUser) {
                showMessageBox("Database not initialized or user not authenticated. Cannot upload data.", "Error");
                return;
            }

            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const uploadedData = JSON.parse(e.target.result);
                    if (!Array.isArray(uploadedData)) {
                        showMessageBox("Invalid backup file. The file should contain an array of lap records.", "Upload Error");
                        return;
                    }

                    // For simplicity, all uploaded laps are saved as PRIVATE laps for the current user.
                    // This prevents unauthorized public uploads and manages data consistently.
                    const privateCollectionPath = `artifacts/${appId}/users/${userId}/laps`;

                    const uploadPromises = uploadedData.map(async (lap) => {
                        // Ensure required fields for a lap are present.
                        // Force visibility to 'private' and associate with current userId.
                        const lapToUpload = {
                            userId: userId, 
                            driverName: lap.driverName || 'Unknown Driver',
                            track: lap.track || 'Unknown Track',
                            layout: lap.layout || 'Unknown Layout',
                            carMake: lap.carMake || 'Unknown Make',
                            carModel: lap.carModel || 'Unknown Model',
                            prCar: parseInt(lap.prCar, 10) || 0,
                            lapTime: lap.lapTime || '00:00:000',
                            lapTimeMs: timeToMilliseconds(lap.lapTime) || 0,
                            timestamp: lap.timestamp || Date.now(),
                            visibility: 'private' // All uploaded laps become private
                        };
                        return addDoc(collection(db, privateCollectionPath), lapToUpload);
                    });

                    await Promise.all(uploadPromises);
                    showMessageBox(`Successfully uploaded ${uploadedData.length} laps as private records. The display will now refresh.`, "Restore Complete");
                    
                    // Reload to ensure all data is consistent and filters are reapplied
                    await loadLapsFromFirestore();
                    populateDriverFilter();
                    aplicarFiltros();

                } catch (error) {
                    console.error("Error uploading data:", error);
                    showMessageBox("Error processing backup file. Please ensure it is a valid JSON file. Error details in console.", "Upload Error");
                } finally {
                    // Clear the file input to allow re-uploading the same file
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }
    </script>
</body>
</html>
