<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GT7 Lap Tracker</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Colors: Oceanic Blue and Grays */
            --primary-color: #376893; /* Oceanic Blue */
            --primary-light-color: #4a7ea4; /* Lighter shade of blue for hover */
            --background-light: #F8F9FA; /* Very light gray for main background */
            --background-medium: #E9ECEF; /* Medium gray for filter background and even rows */
            --text-color: #343A40; /* Dark gray for general text */
            --heading-color: #2F5374; /* Slightly darker blue for headings */
            --border-color: #CED4DA; /* Soft gray for borders */
            --shadow-color: rgba(0, 0, 0, 0.1); /* Standard shadow */
            --fastest-lap-bg: #D4EDDA; /* Green for fastest lap */
            --fastest-lap-text: #155724;
            --error-color: #dc3545; /* Red for error messages */
            --success-color: #28a745; /* Green for success messages */

            /* New Fonts */
            --main-font: 'Roboto', sans-serif;
            --display-font: 'Montserrat', sans-serif; 
        }

        body {
            font-family: var(--main-font);
            margin: 0;
            padding: 20px;
            background-color: var(--background-light);
            color: var(--text-color);
            line-height: 1.6;
        }

        h1, h2 {
            font-family: var(--display-font); /* Montserrat for headings */
            color: var(--heading-color);
            text-align: center;
            margin-bottom: 25px;
            font-weight: 700;
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            margin-bottom: 30px;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
        }

        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group select,
        .form-group input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 1rem;
            color: var(--text-color);
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: var(--main-font); /* Roboto for inputs */
        }

        .form-group input[type="text"]:focus,
        .form-group input[type="number"]:focus,
        .form-group select:focus,
        .form-group input[type="file"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(55, 104, 147, 0.25);
            outline: none;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-right: 15px;
            font-family: var(--display-font); /* Montserrat for buttons */
        }

        button:hover {
            background-color: var(--primary-light-color);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 15px;
            background-color: var(--background-medium);
            border-radius: 10px;
        }

        /* Container for the table that allows horizontal scrolling */
        .table-responsive {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch; /* For smoother scrolling on iOS */
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 2px 8px var(--shadow-color);
            border-radius: 8px;
            overflow: hidden; /* Important for border-radius to apply to content */
            font-family: var(--main-font); /* Roboto for the table */
            min-width: 700px; /* Ensures the table has a minimum width to enable scrolling on small screens if necessary */
        }

        table th, table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid var(--background-medium);
            white-space: nowrap; /* Prevents text from wrapping to multiple lines */
        }

        table th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 700;
            position: sticky;
            top: 0;
            z-index: 1;
            font-family: var(--display-font); /* Montserrat for table headers */
        }

        table tbody tr:nth-child(even) {
            background-color: var(--background-light);
        }

        table tbody tr:hover {
            background-color: var(--background-medium);
            transition: background-color 0.2s ease;
        }

        .fastest-lap {
            background-color: var(--fastest-lap-bg) !important;
            color: var(--fastest-lap-text);
            font-weight: bold;
        }
        
        .error-message {
            color: var(--error-color);
            margin-top: 5px;
            font-size: 0.875em;
            font-weight: 500;
        }

        .backup-section {
            margin-top: 30px;
            border-top: 1px solid var(--border-color);
            padding-top: 25px;
            text-align: center;
        }

        .backup-section p {
            margin-bottom: 15px;
            font-size: 0.95rem;
            color: var(--text-color);
        }

        /* Styles for the custom message box */
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }

        .message-box-overlay.visible {
            visibility: visible;
            opacity: 1;
        }

        .message-box {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .message-box-overlay.visible .message-box {
            transform: translateY(0);
        }

        .message-box h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-family: var(--display-font);
            font-weight: 700;
        }

        .message-box p {
            margin-bottom: 20px;
            color: var(--text-color);
        }

        .message-box button {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background-color 0.3s ease;
            margin-right: 0; /* Override default button margin */
        }

        .message-box button:hover {
            background-color: var(--primary-light-color);
        }

        .user-id-display {
            text-align: center;
            margin-top: 20px;
            color: var(--heading-color);
            font-family: var(--display-font);
            font-weight: 500;
            font-size: 0.9em;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            .container {
                padding: 20px;
            }
            .filters {
                grid-template-columns: 1fr;
            }
            button {
                width: 100%;
                margin-bottom: 10px;
                margin-right: 0;
            }
            table th, table td {
                padding: 10px;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>GT7 Lap Tracker</h1>

        <div class="user-id-display">
            Your User ID: <span id="currentUserId">Loading...</span>
        </div>

        <h2>Register New Lap</h2>
        <div class="form-group">
            <label for="nombrePiloto">Your Driver Name:</label>
            <input type="text" id="nombrePiloto" placeholder="Ex: MyGT7Nick" required>
        </div>
        <div class="form-group">
            <label for="circuito">Track:</label>
            <select id="circuito" onchange="populateLayoutSelect()" required>
                <option value="">Select a track</option>
            </select>
        </div>
        <div class="form-group">
            <label for="trazado">Layout:</label>
            <select id="trazado" required>
                <option value="">Select a layout</option>
            </select>
        </div>
        <div class="form-group">
            <label for="marcaCoche">Car Make:</label>
            <input type="text" id="marcaCoche" placeholder="Ex: Porsche" required>
        </div>
        <div class="form-group">
            <label for="modeloCoche">Car Model:</label>
            <input type="text" id="modeloCoche" placeholder="Ex: 911 GT3 RS" required>
        </div>
        <div class="form-group">
            <label for="prCoche">PR (Performance Rating):</label>
            <input type="number" id="prCoche" min="0" placeholder="Ex: 400" required>
            <div class="error-message" id="prCocheError"></div>
        </div>
        <div class="form-group">
            <label for="tiempoVuelta">Lap Time (mm:ss:SSS):</label>
            <input type="text" id="tiempoVuelta" pattern="[0-5]?\d:[0-5]?\d:\d{3}" placeholder="Ex: 01:30:123" required>
            <div class="error-message" id="tiempoVueltaError"></div>
        </div>
        <button onclick="registrarVuelta()">Register Lap</button>
    </div>

    <div class="container">
        <h2>Registered Laps</h2>

        <div class="filters">
            <div class="form-group">
                <label for="displayMode">Show Laps:</label>
                <select id="displayMode" onchange="saveDisplayModePreference(); aplicarFiltros()">
                    <option value="all">All Laps</option>
                    <option value="mine">My Laps Only</option>
                </select>
            </div>
            <div class="form-group">
                <label for="filterNombrePiloto">Filter by Driver:</label>
                <select id="filterNombrePiloto" onchange="aplicarFiltros()">
                    <option value="">All Drivers</option>
                </select>
            </div>
            <div class="form-group">
                <label for="filterCircuito">Filter by Track:</label>
                <input type="text" id="filterCircuito" onkeyup="aplicarFiltros()" placeholder="All">
            </div>
            <div class="form-group">
                <label for="filterMarcaCoche">Filter by Make:</label>
                <input type="text" id="filterMarcaCoche" onkeyup="aplicarFiltros()" placeholder="All">
            </div>
            <div class="form-group">
                <label for="filterModeloCoche">Filter by Model:</label>
                <input type="text" id="filterModeloCoche" onkeyup="aplicarFiltros()" placeholder="All">
            </div>
            <div class="form-group">
                <label for="filterPrCoche">Filter by PR:</label>
                <input type="number" id="filterPrCoche" onkeyup="aplicarFiltros()" placeholder="All">
            </div>
        </div>

        <div class="table-responsive">
            <table id="tablaVueltas">
                <thead>
                    <tr>
                        <th>Driver</th>
                        <th>Track</th>
                        <th>Layout</th>
                        <th>Make</th>
                        <th>Model</th>
                        <th>PR</th>
                        <th>Time</th>
                        <th>Difference</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        </div>

        <div class="backup-section">
            <h2>Data Management (Backup/Restore)</h2>
            <p>You can download your lap data as a backup file or upload a backup file to restore your data.</p>
            <button onclick="descargarDatos()">Download Backup</button>
            <input type="file" id="subirBackupInput" accept=".json" style="display: none;" onchange="subirDatos(event)">
            <button onclick="document.getElementById('subirBackupInput').click()">Upload Backup</button>
        </div>
    </div>

    <div id="messageBoxOverlay" class="message-box-overlay">
        <div class="message-box">
            <h3 id="messageBoxTitle"></h3>
            <p id="messageBoxContent"></p>
            <button onclick="closeMessageBox()">OK</button>
        </div>
    </div>

    <script type="module">
        // Import Firebase SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, setDoc, doc } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore.js";

        // Firebase configuration provided by the user.
        // It's important that these values match your actual Firebase project settings.
        const userProvidedFirebaseConfig = {
          apiKey: "AIzaSyBYBH1FmAakCH9_istuLv7GgJ65CYimE4U",
          authDomain: "gt7-lap-tracker.firebaseapp.com",
          databaseURL: "https://gt7-lap-tracker-default-rtdb.europe-west1.firebasedatabase.app", // This is for Realtime Database, Firestore is used here
          projectId: "gt7-lap-tracker",
          storageBucket: "gt7-lap-tracker.firebasestorage.app",
          messagingSenderId: "234690775897",
          appId: "1:234690775897:web:93ac912709ca3fe45a9a48",
          measurementId: "G-B6VQWS2B98"
        };

        // Determine Firebase config and app ID for Canvas environment
        // Use __firebase_config if available, otherwise fallback to userProvidedFirebaseConfig
        const firebaseConfig = typeof __firebase_config !== 'undefined'
                               ? JSON.parse(__firebase_config)
                               : userProvidedFirebaseConfig;

        // Use __app_id if available, otherwise fallback to firebaseConfig.appId
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.appId;

        // Use __initial_auth_token for authentication if available
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = 'loading'; // Default to loading state
        let isAuthReady = false; // Flag to indicate if authentication is complete

        const MY_DRIVER_NAME_KEY = 'myDriverName'; // Used for storing the user's driver name locally
        const DISPLAY_MODE_KEY = 'gt7DisplayMode'; // Used for local display preference

        let vueltas = []; // Local array to hold laps fetched from Firestore

        // Gran Turismo 7 Circuits and Layouts
        const circuitosGT7 = {
            "Asia-Pacific": {
                "Autopolis International Racing Course": [],
                "Broad Bean Raceway": [],
                "Fuji International Speedway": [],
                "High Speed Ring": [],
                "Kyoto Driving Park": ["Miyabi", "Yamagiwa", "Yamagiwa + Miyabi"],
                "Mount Panorama": [],
                "Suzuka Circuit": ["Suzuka Circuit East"],
                "Tokyo Expressway": ["Central Inner Loop", "Central Outer Loop", "East Inner Loop", "East Outer Loop", "South Inner Loop", "South Outer Loop"],
                "Tsukuba Circuit": []
            },
            "America": {
                "Autódromo José Carlos Pace": [],
                "Blue Moon Bay Speedway": [],
                "Colorado Springs": [],
                "Daytona International Speedway": ["Daytona Superspeedway", "Daytona Road Course"],
                "Fisherman’s Ranch": [],
                "Northern Isle Speedway": [],
                "Trial Mountain Circuit": [],
                "Special Stage Route X": [],
                "WeatherTech Raceway Laguna Seca": [],
                "Willow Springs International Raceway": ["Big Willow"]
            },
            "Europe": {
                "Alsace – Village": [],
                "Autodrome Lago Maggiore": [],
                "Autodromo Nazionale Monza": [],
                "Brands Hatch": [],
                "Circuit de Barcelona-Catalunya": [],
                "Circuit de la Sarthe": [],
                "Circuit de Sainte-Croix": ["A", "B", "C"],
                "Circuit de Spa-Francorchamps": [],
                "Deep Forest Raceway": [],
                "Dragon Trail": ["Gardens", "Seaside"],
                "Goodwood Motor Circuit": [],
                "Nürburgring": ["24h", "Nordschleife"],
                "Red Bull Ring": [],
                "Sardegna": ["Road Track – A", "Road Track – B", "Road Track – C"],
                "Windmills": []
            }
        };

        /**
         * Converts a time string (mm:ss:SSS) to milliseconds.
         * @param {string} timeStr - The time string to convert.
         * @returns {number} The time in milliseconds, or NaN if invalid.
         */
        function timeToMilliseconds(timeStr) {
            const parts = timeStr.split(':');
            if (parts.length !== 3) return NaN;

            const minutes = parseInt(parts[0], 10);
            const seconds = parseInt(parts[1], 10);
            const milliseconds = parseInt(parts[2], 10);

            if (isNaN(minutes) || isNaN(seconds) || isNaN(milliseconds)) return NaN;

            return (minutes * 60 * 1000) + (seconds * 1000) + milliseconds;
        }

        /**
         * Converts milliseconds to a time string (mm:ss:SSS).
         * @param {number} ms - The time in milliseconds.
         * @returns {string} The formatted time string.
         */
        function millisecondsToTime(ms) {
            if (isNaN(ms)) return 'N/A';

            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = ms % 1000;

            // Pad with leading zeros to ensure correct format
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(3, '0')}`;
        }

        /**
         * Displays a custom message box.
         * @param {string} message - The message content.
         * @param {string} [title='Message'] - The title of the message box.
         */
        function showMessageBox(message, title = 'Message') {
            const overlay = document.getElementById('messageBoxOverlay');
            const titleElement = document.getElementById('messageBoxTitle');
            const contentElement = document.getElementById('messageBoxContent');

            titleElement.textContent = title;
            contentElement.textContent = message;
            overlay.classList.add('visible');
        }

        /**
         * Closes the custom message box.
         */
        function closeMessageBox() {
            const overlay = document.getElementById('messageBoxOverlay');
            overlay.classList.remove('visible');
        }

        /**
         * Populates the Track dropdown in the registration form.
         */
        function populateTrackSelect() {
            const trackSelect = document.getElementById('circuito');
            trackSelect.innerHTML = '<option value="">Select a track</option>'; // Default empty option

            // Iterate through regions and tracks to create optgroups and options
            for (const region in circuitosGT7) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = region;
                
                // Get the tracks for this region
                const tracks = circuitosGT7[region];
                
                // Iterate through the tracks in this region
                for (const trackName in tracks) {
                    const option = document.createElement('option');
                    option.value = trackName;
                    option.textContent = trackName;
                    optgroup.appendChild(option);
                }
                
                trackSelect.appendChild(optgroup);
            }
            populateLayoutSelect(); // Also populate layout on initial load (or track change)
        }

        /**
         * Populates the Layout dropdown based on the currently selected track.
         */
        function populateLayoutSelect() {
            const trackSelect = document.getElementById('circuito');
            const layoutSelect = document.getElementById('trazado');
            const selectedTrack = trackSelect.value;

            // Clear all previous options first
            layoutSelect.innerHTML = ''; 

            if (selectedTrack) { 
                let layouts = [];
                let trackFoundInCircuitosGT7 = false; 

                for (const region in circuitosGT7) {
                    if (circuitosGT7[region][selectedTrack]) { 
                        layouts = circuitosGT7[region][selectedTrack];
                        trackFoundInCircuitosGT7 = true; 
                        break; 
                    }
                }

                if (layouts.length > 0) { 
                    // Add a default "Select a layout" option for tracks with multiple layouts
                    const defaultEmptyOption = document.createElement('option');
                    defaultEmptyOption.value = "";
                    defaultEmptyOption.textContent = "Select a layout";
                    layoutSelect.appendChild(defaultEmptyOption);

                    // Add the actual layouts
                    layouts.forEach(layout => {
                        const option = document.createElement('option');
                        option.value = layout;
                        option.textContent = layout;
                        layoutSelect.appendChild(option);
                    });
                    layoutSelect.value = ""; // Ensure the default empty option is selected initially
                } else { 
                    // If no specific layouts, the track itself is the only layout
                    const option = document.createElement('option');
                    option.value = selectedTrack;
                    option.textContent = selectedTrack;
                    layoutSelect.appendChild(option);
                    layoutSelect.value = selectedTrack; // Automatically select this single option
                }
            } else {
                // If no track is selected in the 'circuito' dropdown, just show the default "Select a layout"
                const defaultEmptyOption = document.createElement('option');
                defaultEmptyOption.value = "";
                defaultEmptyOption.textContent = "Select a layout";
                layoutSelect.appendChild(defaultEmptyOption);
                layoutSelect.value = "";
            }
        }

        // Expose to global scope for HTML onclick attributes
        window.populateLayoutSelect = populateLayoutSelect;
        window.registrarVuelta = registrarVuelta;
        window.aplicarFiltros = aplicarFiltros;
        window.saveDisplayModePreference = saveDisplayModePreference;
        window.descargarDatos = descargarDatos;
        window.subirDatos = subirDatos;
        window.closeMessageBox = closeMessageBox; // Expose close function

        // Event listener for when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', async () => {
            // Populate UI elements immediately, even if Firebase isn't fully ready yet
            populateTrackSelect(); // Moved this to ensure tracks load regardless of auth
            populateDriverFilter(); // Populate driver filter based on initial (empty) laps or local data
            loadDisplayModePreference(); // Load user's preferred display mode

            // Load driver name from local storage
            const storedDriverName = localStorage.getItem(MY_DRIVER_NAME_KEY);
            if (storedDriverName) {
                document.getElementById('nombrePiloto').value = storedDriverName;
            }

            // Initialize Firebase App
            // Only attempt Firebase initialization if API key is present
            if (firebaseConfig.apiKey && firebaseConfig.projectId && firebaseConfig.authDomain) {
                try {
                    app = initializeApp(firebaseConfig);
                    auth = getAuth(app);
                    db = getFirestore(app);

                    // Authenticate using the provided token if available, otherwise sign in anonymously
                    if (initialAuthToken) {
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Signed in with custom token.");
                        } catch (error) {
                            console.error("Error signing in with custom token, falling back to anonymous:", error);
                            await signInAnonymously(auth);
                        }
                    } else {
                        await signInAnonymously(auth);
                    }

                    // Set up authentication listener
                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            document.getElementById('currentUserId').textContent = userId;
                            console.log("Firebase authenticated. User ID:", userId);
                            isAuthReady = true; // Auth is now ready
                            
                            await loadLapsFromFirestore(); // Load laps from Firebase Firestore
                            populateDriverFilter(); // Re-populate driver filter based on loaded laps
                            displayLaps(); // Display laps based on loaded data and filters

                        } else {
                            // This block might be hit if anonymous sign-in fails or user signs out
                            console.warn("No Firebase user signed in after onAuthStateChanged. Check authentication setup.");
                            document.getElementById('currentUserId').textContent = 'Authentication Failed';
                            isAuthReady = false; // Auth failed
                            displayLaps(); // Display what we have, likely empty
                        }
                    });

                } catch (error) {
                    console.error("Error initializing Firebase or during initial authentication:", error);
                    showMessageBox("Firebase initialization failed. Please check your console for errors and ensure your Firebase configuration and settings are correct (e.g., Anonymous sign-in enabled, Firestore rules).", "Initialization Error");
                    document.getElementById('currentUserId').textContent = 'Firebase Error';
                    isAuthReady = false;
                    displayLaps(); // Display what we can without Firebase data
                }
            } else {
                showMessageBox("Firebase configuration is missing or incomplete. Data persistence will be disabled. Please update 'firebaseConfig' in the script.", "Configuration Error");
                document.getElementById('currentUserId').textContent = 'Firebase Not Configured';
                isAuthReady = false; // Firebase won't be used
                displayLaps(); // Just display an empty table or whatever is locally available
            }
        });

        /**
         * Loads all lap data from the "laps" collection in Firestore.
         * The data is sorted by time in milliseconds (fastest first).
         * Updates the global `vueltas` array.
         */
        async function loadLapsFromFirestore() {
            if (!isAuthReady || !db || !auth.currentUser) { // Ensure auth is ready and user is signed in
                console.log("Firestore not ready or user not authenticated. Skipping data load.");
                vueltas = []; // Clear current laps if not ready
                displayLaps(); // Clear table or show loading message
                return;
            }

            vueltas = []; // Clear existing laps
            try {
                // The collection path for public data.
                // This path implies a structure: artifacts -> {appId} -> public -> data -> laps
                // Ensure your Firestore security rules allow reading from this path for anonymous users.
                const lapsCollectionRef = collection(db, `artifacts/${appId}/public/data/laps`);
                
                // Firestore queries cannot order by multiple fields or by fields not indexed.
                // We will fetch all relevant data and sort in-memory.
                const querySnapshot = await getDocs(lapsCollectionRef);

                querySnapshot.forEach((doc) => {
                    vueltas.push({ id: doc.id, ...doc.data() }); // Include doc.id for potential future operations
                });
                console.log("Laps loaded from Firestore:", vueltas.length);
            } catch (e) {
                console.error("Error loading documents from Firestore: ", e);
                showMessageBox("Error loading laps. Please check your internet connection or Firebase Firestore security rules. Ensure rules allow read from 'artifacts/{appId}/public/data/laps'.", "Data Load Error");
            }
        }

        /**
         * Validates the lap time format (mm:ss:SSS).
         * @param {string} time - The time string to validate.
         * @returns {boolean} True if valid, false otherwise.
         */
        function validateTime(time) {
            const regex = /^\d{2}:\d{2}:\d{3}$/;
            return regex.test(time);
        }

        /**
         * Registers a new lap by gathering form data, validating it,
         * and adding it to the Firestore database.
         */
        async function registrarVuelta() {
            if (!db || !auth.currentUser) {
                showMessageBox("Database not initialized or user not authenticated. Please refresh the page or check Firebase configuration.", "Error");
                return;
            }

            const driverName = document.getElementById('nombrePiloto').value.trim();
            const track = document.getElementById('circuito').value.trim();
            const layout = document.getElementById('trazado').value.trim();
            const carMake = document.getElementById('marcaCoche').value.trim();
            const carModel = document.getElementById('modeloCoche').value.trim();
            const prCarInput = document.getElementById('prCoche');
            const prCar = prCarInput.value.trim();
            const lapTime = document.getElementById('tiempoVuelta').value.trim();
            const lapTimeError = document.getElementById('tiempoVueltaError');
            const prCarError = document.getElementById('prCocheError');

            // Clear previous error messages
            lapTimeError.textContent = '';
            prCarError.textContent = '';

            // Basic validation
            if (!driverName || !track || !layout || !carMake || !carModel || !prCar || !lapTime) {
                showMessageBox("Please fill in all fields.", "Validation Error");
                return;
            }

            if (isNaN(parseInt(prCar)) || parseInt(prCar) < 0) {
                prCarError.textContent = 'PR must be a non-negative number.';
                return;
            }

            if (!validateTime(lapTime)) {
                lapTimeError.textContent = 'Lap Time must be in mm:ss:SSS format (e.g., 01:30:123).';
                return;
            }

            const lapTimeMs = timeToMilliseconds(lapTime);
            if (isNaN(lapTimeMs)) {
                lapTimeError.textContent = 'Invalid lap time. Please use mm:ss:SSS format.';
                return;
            }

            // Save driver name to local storage
            localStorage.setItem(MY_DRIVER_NAME_KEY, driverName);

            const newLap = {
                userId: userId, // Store the user ID with the lap
                driverName: driverName,
                track: track,
                layout: layout,
                carMake: carMake,
                carModel: carModel,
                prCar: parseInt(prCar, 10),
                lapTime: lapTime,
                lapTimeMs: lapTimeMs, // Store milliseconds for easier sorting and comparison
                timestamp: Date.now() // Timestamp for ordering
            };

            try {
                // Add a new document with a generated ID to the "laps" collection under the public path
                // Ensure your Firestore security rules allow writing to this path for anonymous users.
                const docRef = await addDoc(collection(db, `artifacts/${appId}/public/data/laps`), newLap);
                console.log("Lap registered with ID: ", docRef.id);
                showMessageBox("Lap registered successfully!", "Success");

                // After successful registration, reload and display laps
                await loadLapsFromFirestore();
                populateDriverFilter(); // Re-populate driver filter as new driver might be added
                aplicarFiltros(); // Apply filters and display updated data
                clearForm();
            } catch (e) {
                console.error("Error adding document: ", e);
                showMessageBox("Error registering lap. Please check your internet connection or Firebase Firestore security rules. Ensure rules allow write to 'artifacts/{appId}/public/data/laps'.", "Registration Error");
            }
        }

        /**
         * Clears the input fields in the registration form.
         */
        function clearForm() {
            // Keep driver name, clear others
            document.getElementById('circuito').value = '';
            document.getElementById('trazado').value = '';
            document.getElementById('marcaCoche').value = '';
            document.getElementById('modeloCoche').value = '';
            document.getElementById('prCoche').value = '';
            document.getElementById('tiempoVuelta').value = '';
            populateLayoutSelect(); // Reset layout dropdown
        }

        /**
         * Populates the "Filter by Driver" dropdown with unique driver names from the loaded laps.
         */
        function populateDriverFilter() {
            const filterDriverSelect = document.getElementById('filterNombrePiloto');
            const currentSelectedDriver = filterDriverSelect.value; // Save current selection

            filterDriverSelect.innerHTML = '<option value="">All Drivers</option>'; // Always have "All Drivers" option

            const uniqueDrivers = new Set(vueltas.map(lap => lap.driverName));
            uniqueDrivers.forEach(driver => {
                const option = document.createElement('option');
                option.value = driver;
                option.textContent = driver;
                filterDriverSelect.appendChild(option);
            });

            // Restore previous selection if it still exists
            if (currentSelectedDriver && uniqueDrivers.has(currentSelectedDriver)) {
                filterDriverSelect.value = currentSelectedDriver;
            } else {
                filterDriverSelect.value = ''; // Reset to "All Drivers" if previous selection is no longer valid
            }
        }

        /**
         * Applies filters and updates the displayed lap table.
         * Filters include display mode (all/mine), driver name, track, car make, car model, and PR.
         * The results are sorted by track, layout, and then lap time.
         */
        function aplicarFiltros() {
            const displayMode = document.getElementById('displayMode').value;
            const filterDriver = document.getElementById('filterNombrePiloto').value.toLowerCase();
            const filterTrack = document.getElementById('filterCircuito').value.toLowerCase();
            const filterMake = document.getElementById('filterMarcaCoche').value.toLowerCase();
            const filterModel = document.getElementById('filterModeloCoche').value.toLowerCase();
            const filterPr = document.getElementById('filterPrCoche').value;

            let filteredVueltas = vueltas.filter(lap => {
                const matchesDriver = filterDriver === '' || lap.driverName.toLowerCase().includes(filterDriver);
                const matchesTrack = filterTrack === '' || lap.track.toLowerCase().includes(filterTrack);
                const matchesMake = filterMake === '' || lap.carMake.toLowerCase().includes(filterMake);
                const matchesModel = filterModel === '' || lap.carModel.toLowerCase().includes(filterModel);
                const matchesPr = filterPr === '' || (lap.prCar && lap.prCar.toString().includes(filterPr)); // Check if prCar exists before toString

                let matchesDisplayMode = true;
                if (displayMode === 'mine' && userId !== 'anonymous_loading' && userId !== 'Firebase Error' && userId !== 'Firebase Not Configured') { // Only filter by 'mine' if a valid userId is available
                    matchesDisplayMode = lap.userId === userId;
                }
                
                return matchesDriver && matchesTrack && matchesMake && matchesModel && matchesPr && matchesDisplayMode;
            });

            // Sort filtered laps: by Track, then Layout, then Lap Time (milliseconds)
            filteredVueltas.sort((a, b) => {
                // Primary sort: Track (alphabetical)
                const trackCompare = a.track.localeCompare(b.track);
                if (trackCompare !== 0) return trackCompare;

                // Secondary sort: Layout (alphabetical)
                const layoutA = a.layout || a.track; // Use track if layout is not specified
                const layoutB = b.layout || b.track;
                const layoutCompare = layoutA.localeCompare(layoutB);
                if (layoutCompare !== 0) return layoutCompare;

                // Tertiary sort: Lap Time (fastest first)
                return a.lapTimeMs - b.lapTimeMs;
            });

            displayLaps(filteredVueltas);
        }

        /**
         * Displays the given array of lap data in the table.
         * Identifies and marks the fastest lap for each unique track/layout combination.
         * @param {Array} [lapsToDisplay=vueltas] - The array of lap objects to display. Defaults to the global `vueltas` array if not provided.
         */
        function displayLaps(lapsToDisplay = vueltas) {
            const tableBody = document.querySelector('#tablaVueltas tbody');
            tableBody.innerHTML = ''; // Clear existing rows

            if (lapsToDisplay.length === 0) {
                const row = tableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 8; // Span all columns
                cell.textContent = "No laps to display. Try registering one or adjusting your filters.";
                cell.style.textAlign = 'center';
                cell.style.padding = '20px';
                return;
            }

            const fastestLaps = {}; // Stores the fastest lap for each track/layout combo { 'TrackName_LayoutName': fastestTimeMs }

            // First pass: Determine the fastest lap for each unique track/layout
            lapsToDisplay.forEach(lap => {
                const key = `${lap.track}_${lap.layout}`;
                if (!fastestLaps[key] || lap.lapTimeMs < fastestLaps[key].lapTimeMs) {
                    fastestLaps[key] = { time: lap.lapTime, lapTimeMs: lap.lapTimeMs };
                }
            });

            // Second pass: Populate the table
            lapsToDisplay.forEach(lap => {
                const row = tableBody.insertRow();

                const key = `${lap.track}_${lap.layout}`;
                const isFastestLap = fastestLaps[key] && lap.lapTimeMs === fastestLaps[key].lapTimeMs;

                if (isFastestLap) {
                    row.classList.add('fastest-lap');
                }

                row.insertCell().textContent = lap.driverName;
                row.insertCell().textContent = lap.track;
                row.insertCell().textContent = lap.layout;
                row.insertCell().textContent = lap.carMake;
                row.insertCell().textContent = lap.carModel;
                row.insertCell().textContent = lap.prCar;
                row.insertCell().textContent = lap.lapTime;

                // Calculate and display difference from fastest lap for the track/layout
                if (fastestLaps[key] && lap.lapTimeMs !== fastestLaps[key].lapTimeMs) {
                    const differenceMs = lap.lapTimeMs - fastestLaps[key].lapTimeMs;
                    const sign = differenceMs > 0 ? '+' : ''; // Add '+' for positive differences
                    row.insertCell().textContent = `${sign}${millisecondsToTime(Math.abs(differenceMs))}`;
                } else {
                    row.insertCell().textContent = ''; // No difference for the fastest lap
                }
            });
        }

        /**
         * Saves the user's preferred display mode ('all' or 'mine') to local storage.
         */
        function saveDisplayModePreference() {
            const displayMode = document.getElementById('displayMode').value;
            localStorage.setItem(DISPLAY_MODE_KEY, displayMode);
        }

        /**
         * Loads the user's preferred display mode from local storage and applies it.
         */
        function loadDisplayModePreference() {
            const storedDisplayMode = localStorage.getItem(DISPLAY_MODE_KEY);
            if (storedDisplayMode) {
                document.getElementById('displayMode').value = storedDisplayMode;
            }
        }

        /**
         * Downloads all current lap data as a JSON file.
         */
        function descargarDatos() {
            const dataStr = JSON.stringify(vueltas, null, 2); // Pretty print JSON
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gt7_lap_data_backup.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox("Your lap data has been downloaded.", "Backup Complete");
        }

        /**
         * Handles uploading a JSON backup file to restore lap data.
         * The uploaded data overwrites the current data in Firestore.
         * @param {Event} event - The file input change event.
         */
        async function subirDatos(event) {
            if (!db || !auth.currentUser) {
                showMessageBox("Database not initialized or user not authenticated. Cannot upload data.", "Error");
                return;
            }

            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const uploadedData = JSON.parse(e.target.result);
                    if (!Array.isArray(uploadedData)) {
                        showMessageBox("Invalid backup file. The file should contain an array of lap records.", "Upload Error");
                        return;
                    }

                    // For a public collection like this, adding new docs is generally safer
                    // than attempting to delete all existing ones without specific user-based queries.
                    // If you truly need to overwrite, you would need more advanced Firestore operations
                    // and appropriate security rules (e.g., specific write access for the user uploading).
                    // This implementation will ADD the laps from the backup.

                    const uploadPromises = uploadedData.map(async (lap) => {
                        // Ensure required fields for a lap are present. Add userId if missing.
                        const lapToUpload = {
                            userId: lap.userId || userId, // Use existing userId from backup or current user's ID
                            driverName: lap.driverName || 'Unknown Driver',
                            track: lap.track || 'Unknown Track',
                            layout: lap.layout || 'Unknown Layout',
                            carMake: lap.carMake || 'Unknown Make',
                            carModel: lap.carModel || 'Unknown Model',
                            prCar: parseInt(lap.prCar, 10) || 0,
                            lapTime: lap.lapTime || '00:00:000',
                            lapTimeMs: timeToMilliseconds(lap.lapTime) || 0,
                            timestamp: lap.timestamp || Date.now()
                        };
                        return addDoc(collection(db, `artifacts/${appId}/public/data/laps`), lapToUpload);
                    });

                    await Promise.all(uploadPromises);
                    showMessageBox("Lap data successfully uploaded and restored! The display will now refresh.", "Restore Complete");
                    
                    // Reload to ensure all data is consistent and filters are reapplied
                    await loadLapsFromFirestore();
                    populateDriverFilter();
                    aplicarFiltros();

                } catch (error) {
                    console.error("Error uploading data:", error);
                    showMessageBox("Error processing backup file. Please ensure it is a valid JSON file. Error details in console.", "Upload Error");
                } finally {
                    // Clear the file input to allow re-uploading the same file
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }
    </script>
</body>
</html>
